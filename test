package com.samsung.android.companionservice.watchface.bnr

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.WorkerParameters
import androidx.work.workDataOf
import com.samsung.android.companionservice.watchface.util.WFLog
import com.samsung.android.plugin.sharedlib.utils.copyFile
import java.io.File

open class WfBnrWorkerBase(cont: Context, param: WorkerParameters) : CoroutineWorker(cont, param) {
    protected var mContext: Context? = null

    override suspend fun doWork(): Result {
        TODO("Not yet implemented")
    }

    open fun init(context: Context) {
        mContext = context
    }

    open fun updateBackupFile() {
        TODO("Not yet implemented")
    }

    open fun backupResource(file: File): Int {
        WFLog.d(TAG, " backupResource ${file.absolutePath}")
        return if (cleanup(file)) {
            if (copyFile()) {
                RESULT_SUCCESS
            } else {
                RESULT_CPY_FAILED
            }
        } else RESULT_CLEANUP_FAILED
    }

    open fun cleanUp(): Boolean {
        return true
    }

    open fun restoreResource(file: File): Int {
        WFLog.d(TAG, " restoreResource ${file.absolutePath}")
        return if (cleanup(file)) {
            if (copyFile()) {
                RESULT_SUCCESS
            } else {
                RESULT_CPY_FAILED
            }
        } else RESULT_CLEANUP_FAILED

    }

    open fun cleanup(target: File): Boolean {
        WFLog.d(TAG, "cleanup : ${target.absolutePath}")
        var res = true
        target?.let { targetFile ->
            if (targetFile.exists()) {
                targetFile.listFiles()?.let {
                    it.forEach {
                        if (!it.delete()) {
                            if (res) res = false
                        }
                        WFLog.w(TAG, "${it.name}  deleted $res")
                    }
                }
            } else {
                targetFile.mkdirs()
            }
        }
        return res
    }

    open fun copyFile(): Boolean {
        return true
    }

    open fun copyDir(source: File, target: File) {
        var makeDirectory = false
        if (source.isDirectory) {
            if (!target.exists()) {
                makeDirectory = target.mkdir()
            }
            WFLog.d(TAG, "Value of MKDIR ::$makeDirectory")
            val children = source.list()
            if (children != null) {
                for (i in children.indices) {
                    copyDir(
                        File(source, children[i]),
                        File(target, children[i])
                    )
                }
            }
        } else {
            copySpecificFile(source, target)
        }
    }

    open fun copySpecificFile(source: File, target: File) {
        return copyFile(source, target)
    }

    open fun setOutPutData(pn: String, fi: Int, reason: Int, isBackup: Boolean): Data {
        return workDataOf(
            WF_RESOURCE_PACKAGE_NAME to pn,
            WF_RESOURCE_FAVORITE_ID to fi,
            REASON to reason,
            BACKUP_STATUS to isBackup
        )
    }

    protected companion object {
        const val TAG = "WfBnrWorkerBase"
        const val WF_RESOURCE_PACKAGE_NAME = "packageName"
        const val WF_RESOURCE_CLASS_NAME = "className"
        const val WF_RESOURCE_FAVORITE_ID = "favoriteId"
        const val ID = "id_"
        const val GM_FOLDER_PATH = "gmfolderPath"
        const val BACKUP_FOLDER = "backup"
        const val GALLERY_FOLDER = "Gallery"
        const val EMOJI_DATA_FOLDER = "galleryFolder"
        const val CUSTOM_PREVIEW = "customize_preview"
        const val RESULT_EXTENSION = "result.xml"
        const val MYPHOTO_FOLDER = "MyPhoto"
        const val MYPEBBLE_FOLDER = "MyPebble"
        const val PHOTOSTICKER_FOLDER = "PhotoSticker"
        const val AREMOJI_BACKUP_FOLDER = "com.samsung.android.watch.watchface.aremoji"
        const val MYPHOTO_BACKUP_FOLDER = "com.samsung.android.watch.watchface.myphoto"
        const val MYPEBBLE_BACKUP_FOLDER = "com.samsung.android.watch.watchface.mypebble"
        const val PHOTOSTICKER_BACKUP_FOLDER = "com.samsung.android.watch.watchface.photosticker"
        const val REASON = "reason"
        const val RESULT_BACKUP_ALREADY_EXIST = 3
        const val RESULT_SRC_NOT_EXIST = 2
        const val RESULT_SUCCESS = 1
        const val RESULT_UNKNOWN_EXCEPTION = 0
        const val RESULT_CPY_FAILED = -3
        const val RESULT_ZIP_FAILED = -4
        const val RESULT_AVATAR_NOT_EXIST = -5
        const val RESULT_CLEANUP_FAILED = -6
        const val RESULT_UNZIP_FAILED = -7
        const val RESULT_IS_DWF = -8
        const val BACKUP_STATUS = "backup_status"
        const val BACKUP_PREFIX = "backup_"

    }
}

package com.samsung.android.companionservice.watchface.bnr

import android.annotation.SuppressLint
import android.content.Context
import androidx.work.Data
import androidx.work.WorkerParameters
import com.samsung.android.companionapps.messagebnr.communication.wifi.WifiDirectTransferTask
import com.samsung.android.companionservice.constant.WatchFaceConstant
import com.samsung.android.companionservice.utils.Compress
import com.samsung.android.companionservice.watchface.util.Decompress
import com.samsung.android.companionservice.watchface.util.WFLog
import com.samsung.android.plugin.sharedlib.utils.SharedFileUtils
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil.deleteDir
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File

class WfBnrListZipWorker(cont: Context, param: WorkerParameters) : WfBnrWorkerBase(cont, param) {
    internal var srcPath: String? = ""
    internal var targetPath: String? = ""
    internal var src: File? = null
    internal var target: File? = null
    internal var path: String? = ""
    internal var output: Data? = null
    var isBackup = false

    @SuppressLint("RestrictedApi")
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            val className = inputData.getString(WF_RESOURCE_CLASS_NAME)
            WFLog.d(TAG, "doWork for $className ")
            isBackup = inputData.getBoolean(BACKUP_STATUS, false)
            val favo = inputData.getInt(WF_RESOURCE_FAVORITE_ID, -1)
            val packageName =
                if (isBackup) inputData.getString(WF_RESOURCE_PACKAGE_NAME) else className!!.substring(
                    0,
                    className!!.lastIndexOf('.')
                )
            var result = 1
            try {
                path = inputData.getString(GM_FOLDER_PATH)
                var resourceFolder = "$packageName${File.separator}$className${File.separator}"
                var backupFolder = "backup${File.separator}$className"
                srcPath = path.plus(if (isBackup) resourceFolder else backupFolder)
                targetPath = path.plus(if (isBackup) backupFolder else resourceFolder)
                src = (if (isBackup) srcPath else srcPath.plus(".zip"))?.let { File(it) }
                target = (if (isBackup) targetPath.plus(".zip") else targetPath)?.let { File(it) }
                if (WatchFaceConstant.DWF_CLASS_NAME == className) {
                    if (!isBackup) {
                        SharedFileUtils.deleteFile(srcPath.plus(".zip"))
                    }
                    output = setOutPutData(packageName!!, favo, RESULT_IS_DWF, isBackup)
                    Result.Success(output!!)
                }
                WFLog.d(TAG, "BNRList srcPath = $srcPath")
                WFLog.d(TAG, "BNRList targetPath = $targetPath")

                if (isBackup && target!!.exists()) {
                    WFLog.d(TAG, "WfBnrListZipWorker target is Exist")
                    result = RESULT_BACKUP_ALREADY_EXIST
                    output = setOutPutData(packageName!!, favo, result, isBackup)
                    Result.Success()
                } else {
                    WFLog.d(TAG, "WfBnrListZipWorker target is not Exist")
                }
                WFLog.d(TAG, "WfBnrListZipWorker copy work start")

                if (!src!!.exists()) {
                    result = RESULT_SRC_NOT_EXIST
                } else {
                    result = if (isBackup) backupResource() else restoreResource()
                }
                output = setOutPutData(packageName!!, favo, result, isBackup)
                if (result <= 0) {
                    Result.Failure(output!!)
                } else {
                    Result.Success()
                }
            } catch (e: Exception) {
                WFLog.w(TAG, "WfBnrListZipWorker Exception : $e")
                output = setOutPutData(packageName!!, favo, RESULT_UNKNOWN_EXCEPTION, isBackup)
                Result.Failure(output!!)
            }!!
        }
    }

    private fun backupResource(): Int {
        return if (copyFile()) {
            if (zipFile()) {
                RESULT_SUCCESS
            } else {
                RESULT_ZIP_FAILED
            }
        } else {
            RESULT_CPY_FAILED
        }
    }

    private fun restoreResource(): Int {
        var a1 = srcPath!!.plus(".zip")
        var a2 = targetPath!!.removeSuffix("/").let { it.substring(0, it.lastIndexOf("/")) }
        WFLog.d(TAG, "restoreResource a1 : $a1")
        WFLog.d(TAG, "restoreResource a2: $a2")
        return if (Decompress.unzip(a1, a2)) {
            WFLog.d(TAG, "restoreResource success")
            RESULT_SUCCESS
        } else {
            WFLog.d(TAG, "restoreResource failed")
            RESULT_UNZIP_FAILED
        }
    }

    fun zipFile(): Boolean {
        WFLog.d(TAG, "zipFile BNRList");
        var backupPath = path.plus("backup")
        var zipPath = targetPath
        var zipFilePath = targetPath.plus(".zip")
        WFLog.d(TAG, "zipFile backupPath : $backupPath")
        WFLog.d(TAG, "zipFile zipPath : $zipPath")
        WFLog.d(TAG, "zipFile zipFilePath : $zipFilePath")
        val cmp = Compress(zipFilePath, zipPath!!)
        WFLog.w(TAG, "zipFile compress : ${cmp.zip()}")
        return deleteDir(zipPath)
    }


    override fun copyFile(): Boolean {
        WFLog.d(TAG, "copyFile BNRList");
        src!!.listFiles()?.let {
            var zipDirEntry = it.filter { it.isDirectory && it.name.startsWith("id") }
            if (!zipDirEntry.isNullOrEmpty()) {
                for (dir in zipDirEntry) {
                    dir.listFiles()?.let { child ->
                        var tempPath = targetPath!!.plus("${File.separator}${dir.name}")
                        var tempDir = File(tempPath)
                        if (!tempDir.exists()) {
                            tempDir.mkdirs()
                        }
                        child.filter {
                            it.name.endsWith(RESULT_EXTENSION) ||
                                    it.name.contains(CUSTOM_PREVIEW) ||
                                    ((it.isDirectory) && (it.name.equals(EMOJI_DATA_FOLDER)))
                        }
                            ?.forEach {
                                var tempFile = File(tempPath.plus("${File.separator}${it.name}"))
                                if (it.isDirectory) {
                                    copyDir(it, tempFile)
                                } else {
                                    copySpecificFile(it, tempFile)
                                }
                            }
                    }
                }
            } else {
                WFLog.d(TAG, "copyFile zipDirEntry is null");
            }
        }
        WFLog.d(TAG, "copyFile end");
        return true
    }

    companion object {
        val TAG = "WfBnrListZipWorker"
    }

}
