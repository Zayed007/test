package com.samsung.android.companionservice.watchface.manager

import android.content.Context
import android.net.Uri
import android.text.TextUtils
import com.google.android.gms.wearable.DataMap
import com.samsung.android.app.watchmanager.plugin.libfactory.util.FileEncryptionUtils.Companion.getEncryptionContext
import com.samsung.android.companionservice.aidl.watchface.*
import com.samsung.android.companionservice.constant.WatchFaceConstant
import com.samsung.android.companionservice.watchface.database.DbManager
import com.samsung.android.companionservice.watchface.util.WFLog
import com.samsung.android.companionservice.watchface.util.WatchFaceUtil
import com.samsung.android.companionservice.watchface.util.WatchfaceCategoryUtil
import com.samsung.android.companionservice.watchface.util.WatchfacePreference
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedConstant
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil.isAvailableWatchfaceFeatureUsed
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil.setOSCapability
import java.util.stream.Collectors

object WatchfaceDataMap {
    private val TAG = "WatchfaceDataMap"
    private val LockDatabase = Any()
    private val mUpdateHashMap = HashMap<String, Boolean>()
    private val mRelatedAppHashMap = HashMap<String, Boolean>()
    private val mDeviceNodeMap = HashMap<String, String>()
    private val backupConfigDataHash = HashMap<String, DataMap>()
    private var mProtectDefaultWatchFaceSet: WatchfacePackageClassSet? = null
    private var mWatchfaceOrderList: WatchfaceOrderList? = null
    private var mCurrentEditWatchface: ExWatchFace? = null
    private var mDbManager: DbManager? = null
    private var oobe_fileUri: Uri? = null
    private var isSupportNewFeature = WatchFaceSharedConstant.NOT_EXIST
    private var isFavoriteLIst = false
    private var isFotaUpdate = false
    private var isWatchfaceEditWithUserStyle = false

    @JvmStatic
    fun setBackupDataConfig(key: String, config: DataMap?) {
        WFLog.d(TAG, "setBackupDataConfig() $ $key")
        if (config != null) {
            WFLog.d(TAG, "setBackupDataConfig() $  setted $key")
            backupConfigDataHash.put(key, config)
        } else {
            WFLog.d(TAG, "setBackupDataConfig() $  removed $key")
            backupConfigDataHash.remove(key)
        }
    }

    @JvmStatic
    fun getBackupDataConfig(key: String): DataMap? {
        WFLog.d(TAG, "getBackupDataConfig() $key")
        backupConfigDataHash.let {
            if (it.containsKey(key)) {
                return it.get(key)
            } else {
                WFLog.e(TAG, "getBackupDataConfig() does not contains key : $key")
            }
        }
        return null
    }

    @JvmStatic
    public var restoreState: String? = null
        get() = field ?: "null"
        set(state) {
            field = state
        }

    @JvmStatic
    fun init(context: Context) {
        if (mDbManager == null)
            mDbManager = DbManager.getInstance(
                getEncryptionContext(context)
            )
    }

    @JvmStatic
    fun getFotaUpdate(): Boolean {
        return isFotaUpdate
    }

    @JvmStatic
    fun setFotaUpdate(fotaUpdate: Boolean) {
        isFotaUpdate = fotaUpdate
    }

    @JvmStatic
    fun setProtectDefaultWatchFace(packageName: String, className: String, favoriteId: Int) {
        WFLog.w(TAG, "setProtectDefaultWatchFace() :: $packageName / $className  / $favoriteId")
        if (!TextUtils.isEmpty(packageName) && !TextUtils.isEmpty(className)) {
            mProtectDefaultWatchFaceSet =
                WatchfacePackageClassSet(packageName, className, favoriteId)
        }
    }

    @JvmStatic
    fun resetProtectDefaultWatchFace() {
        WFLog.d(TAG, "resetProtectDefaultWatchFace()")
        mProtectDefaultWatchFaceSet = null
    }

    @JvmStatic
    fun isProtectedDefaultWatchFaceSetExist(packageName: String, className: String): Boolean {
        if (mProtectDefaultWatchFaceSet != null) {
            if (mProtectDefaultWatchFaceSet!!.packageName == packageName &&
                mProtectDefaultWatchFaceSet!!.className == className
            ) {
                WFLog.w(TAG, "isProtectedDefaultWatchFaceSetExist $className")
                return true
            }
        }
        return false
    }

    @JvmStatic
    fun isProtectedDefaultWatchFace(packageName: String, className: String): Boolean {
        return if (mProtectDefaultWatchFaceSet != null) {
            mProtectDefaultWatchFaceSet!!.packageName == packageName &&
                    mProtectDefaultWatchFaceSet!!.className == className
        } else false
    }

    @JvmStatic
    fun getProtectedDefaultWatchFaceFavroiteId(packageName: String, className: String): Int {
        if (mProtectDefaultWatchFaceSet != null) {
            if (mProtectDefaultWatchFaceSet!!.packageName == packageName &&
                mProtectDefaultWatchFaceSet!!.className == className
            ) {
                return mProtectDefaultWatchFaceSet!!.favoriteId
            }
        }
        return WatchFaceConstant.UNKNOWN_FAVORITE_ID
    }

    @JvmStatic
    fun updateProtectedDefaultWatchFaceFavroiteId(
        packageName: String,
        className: String,
        favoriteId: Int
    ) {
        if (mProtectDefaultWatchFaceSet != null) {
            if (mProtectDefaultWatchFaceSet!!.packageName == packageName &&
                mProtectDefaultWatchFaceSet!!.className == className
            ) {
                mProtectDefaultWatchFaceSet!!.favoriteId = favoriteId
            }
        }
    }

    @JvmStatic
    fun isProtectedDefaultWatchFaceSetExist(): Boolean {
        return mProtectDefaultWatchFaceSet != null
    }

    @JvmStatic
    fun resetDataBase(context: Context, deviceID: String) {
        WFLog.w(TAG, "resetDataBase $deviceID")
        mDeviceNodeMap.clear()
        WatchfaceCategoryUtil.resetCategoryList(context, deviceID)
        WatchFaceUtil.resetDataFolder(context, deviceID)
        WatchFaceUtil.resetWatchfacePrefenses(context, deviceID, false)
        isSupportNewFeature = WatchFaceSharedConstant.NOT_EXIST
        setOSCapability(context, deviceID, isSupportNewFeature)
        if (mDbManager != null) {
            mDbManager!!.resetDataBase(deviceID)
        }
        mUpdateHashMap.clear()
        mRelatedAppHashMap.clear()
//        isHolidayWatchfaceUpdated = false
    }

    @JvmStatic
    fun setPeerID(deviceID: String, peerID: String) {
        mDeviceNodeMap[deviceID] = peerID
        mDbManager!!.checkAndCreateTable(deviceID)
    }

    @JvmStatic
    fun getPeerID(deviceID: String?): String {
        var peerId = mDeviceNodeMap[deviceID]
        if (peerId == null) peerId = "00"
        return peerId
    }

    @JvmStatic
    fun getDeviceID(peerID: String): String? {
        if (mDeviceNodeMap.isEmpty())
            return null
        for (element: Map.Entry<String, String> in mDeviceNodeMap) {
            if (element.value == peerID)
                return element.key
        }
        return null
    }

    @JvmStatic
    fun setIdleWatchface(context: Context?, deviceID: String?, idle: ExWatchFace?) {
        if (idle == null)
            return

        synchronized(LockDatabase) {
            if (mDbManager != null) {
                mDbManager!!.setIdleWatchface(
                    idle.packageName,
                    idle.className,
                    idle.favoriteId,
                    deviceID
                )
                mDbManager!!.updateWatchfaceNewlyDownloadedInfo(
                    idle.packageName,
                    idle.className,
                    false,
                    deviceID
                )
            }
        }
        WatchfacePreference.setIdleWatchface(context, deviceID, idle.packageName, idle.className)
        WFLog.d(
            TAG,
            "setIdleWatchface " + idle.packageName + "  " + idle.className + "   type : " + idle.type
        )
    }

    @JvmStatic
    fun setIdleWatchface(
        context: Context?,
        deviceID: String?,
        idlePackageName: String?,
        idleClassName: String,
        favoriteId: Int
    ) {
        synchronized(LockDatabase) {
            if (mDbManager != null) {
                mDbManager!!.setIdleWatchface(idlePackageName, idleClassName, favoriteId, deviceID)
                mDbManager!!.updateWatchfaceNewlyDownloadedInfo(
                    idlePackageName,
                    idleClassName,
                    false,
                    deviceID
                )
            }
        }
        WatchfacePreference.setIdleWatchface(context, deviceID, idlePackageName, idleClassName)
        WFLog.d(TAG, "setIdleWatchface idleClassName $idleClassName")
    }

    @JvmStatic
    fun getIdleWatchface(deviceId: String?): ExWatchFace? {
        var idle: ExWatchFace? = null
        synchronized(LockDatabase) {
            if (mDbManager != null)
                idle = mDbManager!!.getIdleWatchface(deviceId)
            WFLog.d(TAG, "getIdleWatchface $idle")
        }
        return idle
    }

    @JvmStatic
    fun setCurrentEditWatchface(watchface: ExWatchFace) {
        WFLog.w(TAG, "setCurrentEditWatchface : " + watchface.className)
        mCurrentEditWatchface = watchface
    }

    @JvmStatic
    fun getCurrentEditWatchface(deviceId: String?): ExWatchFace? {
        if (mCurrentEditWatchface == null) {
            mCurrentEditWatchface = getIdleWatchface(deviceId)
        }
        return mCurrentEditWatchface
    }

    @JvmStatic
    fun getWatchfaceByClassName(className: String?, deviceId: String?): ExWatchFace? {
        var wf: ExWatchFace? = null
        synchronized(LockDatabase) {
            if (mDbManager != null)
                wf = mDbManager!!.getWatchfaceByClassName(className, deviceId)
            WFLog.d(TAG, "getWatchfaceByClassName $wf")
        }
        return wf
    }

    @JvmStatic
    fun getWatchfaceByPackageName(packageName: String?, deviceId: String?): ExWatchFace? {
        var wf: ExWatchFace? = null
        synchronized(LockDatabase) {
            if (mDbManager != null)
                wf = mDbManager!!.getWatchfaceByPackageName(packageName, deviceId)
            WFLog.d(TAG, "getWatchfaceByPackageName $wf")
        }
        return wf
    }

    @JvmStatic
    fun getAvailableWatchface(
        packageName: String?,
        className: String?,
        deviceId: String?
    ): ExWatchFace? {
        var wf: ExWatchFace? = null
        synchronized(LockDatabase) {
            if (mDbManager != null)
                wf = mDbManager!!.getAvailableWatchFace(packageName, className, deviceId)
            WFLog.d(TAG, "getAvailableWatchFace $wf")
        }
        return wf
    }

    @JvmStatic
    fun getFavoriteWatchface(
        packageName: String?,
        className: String?,
        favoriteId: Int,
        deviceId: String?
    ): ExWatchFace? {
        var wf: ExWatchFace? = null
        synchronized(LockDatabase) {
            if (mDbManager != null)
                wf = mDbManager!!.getFavoriteWatchFace(packageName, className, favoriteId, deviceId)
            WFLog.d(TAG, "getFavoriteWatchface $wf")
        }
        return wf
    }

    @JvmStatic
    fun getFavoriteWatchface(
        packageName: String?,
        className: String?,
        deviceId: String?
    ): List<ExWatchFace?>? {
        val watchFaceArrayList = mDbManager!!.getFavoriteWfList(deviceId, mUpdateHashMap, mRelatedAppHashMap)
        return watchFaceArrayList.stream().filter { exWatchFace ->
            exWatchFace.className.equals(className) && exWatchFace.packageName
                .equals(packageName)
        }.collect(Collectors.toList())
    }

    @JvmStatic
    fun setWatchFaceOrderType(context: Context?, deviceID: String?, orderType: WatchfaceOrderType?) {
        WFLog.w(TAG, "setWatchFaceOrderType : $orderType")
        WatchfacePreference.setWatchFaceOrderType(context, deviceID, orderType)
    }

    /**
     * @return true: Order type is most recent first, false: Order type is custom
     */
    @JvmStatic
    fun getWatchFaceOrderType(context: Context?, deviceID: String?): WatchfaceOrderType {
        val orderType = WatchfacePreference.getWatchFaceOrderType(context, deviceID)
        WFLog.w(TAG,"getWatchFaceOrderType : $orderType")
        return orderType
    }

    @JvmStatic
    fun setWatchFaceOrderList(orderList: WatchfaceOrderList?, deviceID: String?): Boolean {
        if (orderList == null) {
            return false
        }
        synchronized(LockDatabase) {
            if (mDbManager == null) {
                return false
            }
            val result = mDbManager!!.updateWatchFaceOrder(orderList, deviceID)
            if (isFavoriteLIst && result) {
                if (mWatchfaceOrderList != null) {
                    mWatchfaceOrderList!!.clear()
                    mWatchfaceOrderList = null
                }
            } else {
                mWatchfaceOrderList = orderList
            }
            return result
        }
    }

//    @JvmStatic
//    fun setHolidayWatchfaceUpdated(set: Boolean) {
//        isHolidayWatchfaceUpdated = set
//    }
//
//    @JvmStatic
//    fun isHolidayWatchfaceUpdated(): Boolean {
//        return isHolidayWatchfaceUpdated
//    }

    @JvmStatic
    fun setUpdateWatchfaceList(
        updateList: HashMap<String, Boolean>,
        relatedAppList: HashMap<String, Boolean>
    ) {
        mUpdateHashMap.clear()
        mUpdateHashMap.putAll(updateList)
        mRelatedAppHashMap.clear()
        mRelatedAppHashMap.putAll(relatedAppList)
        WFLog.w(TAG, "setUpdateWatchfaceList : " + updateList.size + "  " + relatedAppList.size)
    }

    @JvmStatic
    fun getFavoriteWatchfaceList(
        deviceID: String?
    ): ArrayList<ExWatchFace> {
        var watchFaceArrayList = ArrayList<ExWatchFace>()
        synchronized(LockDatabase) {
            if (mDbManager != null) {
                watchFaceArrayList =
                    mDbManager!!.getFavoriteWfList(deviceID, mUpdateHashMap, mRelatedAppHashMap)
            }
        }
        WFLog.w(TAG, "getFavoriteWatchfaceList : " + watchFaceArrayList.size)
        return watchFaceArrayList
    }

    private var mAvailableWatchfaceList: ArrayList<ExWatchFaceList> = ArrayList<ExWatchFaceList>()

    @JvmStatic
    fun getAvailableWatchfaceListCount(deviceId: String?): Int {
        getAvailableWatchfaceListInternal(deviceId)
        return mAvailableWatchfaceList.size
    }

    @JvmStatic
    fun getAvailableWatchfaceList(deviceId: String?, num: Int): ArrayList<ExWatchFace>? {
        return if(num > mAvailableWatchfaceList.size)
            null
        else {
            WFLog.d(TAG, "getAvailableWatchfaceList : $num / " + mAvailableWatchfaceList[num].watchfaceList.size)
            mAvailableWatchfaceList[num].watchfaceList
        }
    }

    @JvmStatic
    fun getAvailableWatchfaceList(deviceId: String?): ArrayList<ExWatchFace>? {
        var count = mAvailableWatchfaceList.size
        if(count == 0)
            return null

        var availableList:ArrayList<ExWatchFace> = ArrayList<ExWatchFace>()
        for(i in 0 until count)
            availableList.addAll(mAvailableWatchfaceList[i].watchfaceList)
        return availableList
    }

    @JvmStatic
    fun getAvailableWatchfaceListInternal(deviceId: String?): ArrayList<ExWatchFaceList> {
        synchronized(LockDatabase) {
            if (mDbManager != null)
                mAvailableWatchfaceList = mDbManager!!.getAvailableWfList(deviceId, mUpdateHashMap, mRelatedAppHashMap)
        }
        return mAvailableWatchfaceList
    }


    @JvmStatic
    fun setFavoriteWatchfaceList(
        deviceID: String?,
        watchfaceList: HashMap<String, ExWatchFace>,
        isFavorite: Boolean
    ): Boolean {
        WFLog.w(TAG, "setFavoriteWatchfaceList : " + deviceID + "    " + watchfaceList.size)
        synchronized(LockDatabase) {
            if (mDbManager == null) {
                return false
            }
            mDbManager!!.checkDuplicateFavoriteListUpdate(watchfaceList, deviceID)
            isFavoriteLIst = isFavorite
            watchfaceList.clear()
            if (mWatchfaceOrderList == null) {
                return false
            }
            WFLog.w(TAG,"setFavoriteWatchfaceList : OrderList : " + mWatchfaceOrderList!!.orderList.size)
            val result = mDbManager!!.updateWatchFaceOrder(mWatchfaceOrderList, deviceID)
            if (isFavoriteLIst && result) {
                mWatchfaceOrderList!!.clear()
                mWatchfaceOrderList = null
                return true
            }
            return false
        }
    }

    @JvmStatic
    fun setAvailableWatchfaceList(deviceId: String?, availableList: HashMap<String, ExWatchFace>) {
        WFLog.w(TAG, "setAvailableWatchfaceList : " + deviceId + "    " + availableList.size)
        synchronized(LockDatabase) {
            if (mDbManager != null) {
                mDbManager!!.checkDuplicateAvailableListUpdate(availableList, deviceId)
                availableList.clear()
            }
        }
    }

    @JvmStatic
    fun updateWatchfacePreloadTypeInfo(packageName: String, className: String, type: String, deviceID: String?) {
        WFLog.w(TAG,"updateWatchfacePreloadTypeInfo : $packageName  $className  $type")
        synchronized(LockDatabase) {
            if (mDbManager != null)
                mDbManager!!.updateWatchfacePreloadTypeInfo(
                packageName,
                className,
                type,
                deviceID
            )
        }
    }

    @JvmStatic
    fun setWatchFaceType(packageName: String, className: String, type: String, deviceID: String?) {
        WFLog.w(TAG,"setWatchFaceType : $packageName  $className  $type")
        synchronized(LockDatabase) {
            if (mDbManager != null)
                mDbManager!!.updateWatchfaceTypeInfo(
                packageName,
                className,
                type,
                deviceID
            )
        }
    }

    @JvmStatic
    fun setWatchFaceVersion(
        packageName: String,
        className: String,
        version: Int,
        deviceID: String?
    ) {
        WFLog.w(TAG,"setWatchFaceVersion : $packageName  $className  $version")
        synchronized(LockDatabase) {
            if (mDbManager != null)
                mDbManager!!.updateWatchfaceVersionInfo(
                packageName,
                className,
                version,
                deviceID
            )
        }
    }

    @JvmStatic
    fun getWatchFaceVersion(packageName: String, className: String, deviceId: String?): Int {
        var result = 0
        var watchFace: ExWatchFace?
        synchronized(LockDatabase) {
            if (mDbManager != null) {
                watchFace = mDbManager!!.getAvailableWatchFace(packageName, className, deviceId)
                if (watchFace != null)
                    result = watchFace!!.version
            }
        }
        WFLog.w(TAG,"getWatchFaceVersion : $packageName  $className  $result")
        return result
    }

    @JvmStatic
    fun setWatchFaceAppVersion(
        packageName: String,
        className: String,
        appVersion: Long,
        deviceID: String?
    ) {
        WFLog.w(TAG,"setWatchFaceAppVersion : $packageName  $className  $appVersion")
        synchronized(LockDatabase) {
            if (mDbManager != null)
                mDbManager!!.updateWatchfaceAppVersionInfo(
                    packageName,
                    className,
                    appVersion,
                    deviceID
                )
        }
    }

    @JvmStatic
    fun getWatchFaceAppVersion(packageName: String, className: String, deviceId: String?): Long {
        var result = 0L
        var watchFace: ExWatchFace?
        synchronized(LockDatabase) {
            if (mDbManager != null) {
                watchFace = mDbManager!!.getAvailableWatchFace(packageName, className, deviceId)
                if (watchFace != null)
                    result = watchFace!!.appVersion
            }
        }
        WFLog.w(TAG,"getWatchFaceAppVersion : $packageName  $className  $result")
        return result
    }

    @JvmStatic
    fun setCategoryData(
        context: Context?,
        categoryLists: ArrayList<CategoryLists>?,
        deviceId: String?
    ) {
        if (categoryLists == null || categoryLists.isEmpty()) {
            return
        }
        WFLog.w(TAG, "setCategoryData : " + categoryLists.size)
        synchronized(LockDatabase) {
            convertCategoryPackageClass(categoryLists)
            if (mDbManager == null) {
                categoryLists.clear()
                return
            }
            if (mDbManager!!.updateWatchFaceCategoryInfo(categoryLists, deviceId)) {
                val versionValue = WatchfaceCategoryUtil.getCategoryVersionFromAsset(context)
                if (versionValue != -1) {
                    WatchfaceCategoryUtil.setCategoryListVersion(context, versionValue, deviceId)
                }
            }
            categoryLists.clear()
        }
    }

    @JvmStatic
    fun getPreloadPackageName(className: String, deviceId: String?): String? {
        var packageName = mCategoryPackageClass[className]
        if (!TextUtils.isEmpty(className) && TextUtils.isEmpty(packageName)) {
            val watchFace = getWatchfaceByClassName(className, deviceId)
            if (watchFace != null) packageName = watchFace.packageName
        }
        return packageName
    }

    @JvmStatic
    fun getPreloadClassName(packageName: String, deviceId: String?): String? {
        if(mCategoryPackageClass.isNotEmpty()) {
            mCategoryPackageClass.forEach{ (cName, pName) ->
                if(pName == packageName)
                    return cName
            }
        }
        var className: String? = null
            val watchFace = getWatchfaceByPackageName(className, deviceId)
            if (watchFace != null) className = watchFace.className
        return className
    }

    var mCategoryPackageClass = HashMap<String, String>()

    @JvmStatic
    fun convertCategoryPackageClass(categoryLists: ArrayList<CategoryLists>?) {
        if (categoryLists == null || categoryLists.isEmpty()) {
            return
        }
        for (list in categoryLists) {
            if (list.categoryContentList == null || list.categoryContentList.isEmpty()) {
                continue
            }
            for (category in list.categoryContentList) {
                if (category == null || category.packageName == null || category.className == null) {
                    continue
                }
                mCategoryPackageClass[category.className] = category.packageName
            }
        }
    }

    @JvmStatic
    fun getCategoryData(deviceId: String?): ArrayList<CategoryLists>? {
        var categoryLists: ArrayList<CategoryLists>? = null
        if (mDbManager != null) {
            categoryLists = mDbManager!!.getWatchFaceCategoryLists(deviceId)
        }
        if (categoryLists != null) {
            WFLog.w(TAG, "getCategoryData : " + categoryLists.size)
            if (categoryLists.isNotEmpty())
                convertCategoryPackageClass(categoryLists)
        }
        //Add Edition Category
        val availableWatchFaceList = getAvailableWatchfaceListInternal(deviceId)
        val editionCategory = ArrayList<CategoryList>()
        availableWatchFaceList.forEach {
            for (watchFace in it.watchfaceList) {
                val checkWatchface =
                    PreloadedEditionWatchFace.WatchfaceEditionPreloadHashMap[watchFace.packageName]
                if (checkWatchface != null
                    && (checkWatchface.className == watchFace.className || WatchFaceConstant.DWF_CLASS_NAME == watchFace.className)) {
                    WFLog.w(
                        TAG,
                        "getCategoryData:: added to edition category, Package name " + checkWatchface.packageName
                    )
                    val categoryItem = CategoryList(
                        watchFace.displayName,
                        "",
                        watchFace.packageName,
                        watchFace.className,
                        watchFace.previewImageFileName,
                        true
                    )
                    editionCategory.add(categoryItem)
                }
            }
        }
        if (!editionCategory.isEmpty()) {
            val editionCategoryItem = CategoryLists(
                WatchFaceConstant.WATCH_FACE_EDITION_CATEGORY_NAME,
                WatchFaceConstant.CATEGORY_NAME_EDITION_TITLE,
                null,
                WatchFaceUtil.sortCategoryItem(editionCategory)
            )
            categoryLists!!.add(0, editionCategoryItem)
        }
        return categoryLists
    }

    private var preloadCount = -1

    @JvmStatic
    fun getPreloadCount(deviceId: String?): Int {
        if (preloadCount == -1) {
            if (mDbManager != null) {
                preloadCount = mDbManager!!.getPreloadWatchfaceCount(deviceId)
            }
        }
        WFLog.d(TAG,"getPreloadCount : $preloadCount")
        return preloadCount
    }

    private val ConditionalDataMap = HashMap<String, Boolean>()

    @JvmStatic
    fun isConditionalComplicationDataExisted(context: Context?, deviceId: String): Boolean {
        var isExisted = ConditionalDataMap[deviceId]
        if (isExisted == null || isExisted == false) {
            isExisted = WatchfacePreference.isConditionalComplicationDataExisted(context, deviceId)
            ConditionalDataMap[deviceId] = isExisted
        }
        return isExisted
    }

    @JvmStatic
    fun getConditionalComplication(context: Context?, deviceId: String?): ConditionalComplication? {
        return if (deviceId == null) {
            null
        } else WatchfacePreference.getConditionalComplication(context, deviceId)
    }

    var mResourcePackageClass = HashMap<String, WatchfacePackageClassSet?>()

    @JvmStatic
    fun putPackageClassNameForResource(packageName: String, className: String?) {
        val packageClassSet = mResourcePackageClass[packageName]
        if (packageClassSet == null) {
            mResourcePackageClass[packageName] = WatchfacePackageClassSet(packageName, className)
        }
    }

    @JvmStatic
    fun getClassNameForResource(packageName: String): String? {
        return if (mResourcePackageClass[packageName] != null) {
            mResourcePackageClass[packageName]!!.className
        } else null
    }

    @JvmStatic
    fun setVersionInfoForResource(packageName: String, className: String?, version: Int) {
        if (mResourcePackageClass[packageName] == null) {
            putPackageClassNameForResource(packageName, className)
        }
        if (mResourcePackageClass[packageName] != null) {
            mResourcePackageClass[packageName]!!.versionInfo = version
        }
    }

    @JvmStatic
    fun getVersionInfoForResource(packageName: String): Int {
        return if (mResourcePackageClass[packageName] != null) {
            mResourcePackageClass[packageName]!!.versionInfo
        } else {
            val wf = getWatchfaceByPackageName(packageName, WatchFaceSharedUtil.getDeviceID())
            wf?.version ?: 0
        }
    }

    @JvmStatic
    fun setWatchFaceDotInformation(dotInfo: WatchfaceDotInformation, deviceId: String) {
        for(item in dotInfo.badgeList)
            WFLog.d(TAG, "dotInfo : ${item.packageName}")

        //mUpdateHashMap ??
    }

    @JvmStatic
    fun setCustomizableItemResourceData(
        packageName: String,
        className: String,
        customizableText: String,
        deviceId: String?
    ): Boolean {
        var result = false
        synchronized(LockDatabase) {
            if (mDbManager != null)
                result = mDbManager!!.updateCustomizableItemResourceData(
                packageName,
                className,
                customizableText,
                deviceId
            )
        }
        WFLog.w(TAG,"setCustomizableItemResourceData : $packageName  $className  $customizableText")
        return result
    }

    @JvmStatic
    fun getCustomizableItemResourceData(
        packageName: String,
        className: String,
        deviceId: String?
    ): String {
        var customizableText = ""
        synchronized(LockDatabase) {
            if (mDbManager != null)
                customizableText = mDbManager!!.getCustomizableItemResourceData(packageName, className, deviceId)
        }
        WFLog.w(TAG,"getCustomizableItemResourceData : $packageName  $className  $customizableText")
        return customizableText
    }

    @JvmStatic
    fun changeCustomizableItemResourceStatus(
        packageName: String,
        className: String,
        deviceId: String?,
        update: Boolean?
    ): Boolean {
        var customizableText: String?
        var result = false
        synchronized(LockDatabase) {
            if (mDbManager != null) {
                customizableText =
                    mDbManager!!.getCustomizableItemResourceData(packageName, className, deviceId)
                val data =
                    WatchFaceUtil.checkCustomizableText(customizableText)
                if (data != null) {
                    data.isUpdated = update!!
                    result = setCustomizableItemResourceData(
                        packageName,
                        className,
                        data.toJsonString(),
                        deviceId
                    )
                }
            }
        }
        return result
    }

    var mCustomizableItemJsonResource = HashMap<String, WatchfacePackageClassSet?>()

    @JvmStatic
    fun putPackageClassNameForJsonResource(packageName: String, className: String?) {
        val packageClassSet = mCustomizableItemJsonResource[packageName]
        if (packageClassSet == null) {
            mCustomizableItemJsonResource[packageName] =
                WatchfacePackageClassSet(packageName, className)
        }
    }

    @JvmStatic
    fun setVersionInfoForJsonResource(packageName: String, className: String?, version: Int) {
        if (mCustomizableItemJsonResource[packageName] == null) {
            putPackageClassNameForJsonResource(packageName, className)
        }
        if (mCustomizableItemJsonResource[packageName] != null) {
            mCustomizableItemJsonResource[packageName]!!.versionInfo = version
        }
    }

    @JvmStatic
    fun getVersionInfoForJsonResource(packageName: String): Int {
        return if (mCustomizableItemJsonResource[packageName] != null) {
            mCustomizableItemJsonResource[packageName]!!.versionInfo
        } else 0
    }

    @JvmStatic
    fun isSupportNewFeature(context: Context?): Boolean {
        if (isSupportNewFeature >= WatchFaceSharedConstant.NEW_FEATURE_AVAILABLE)
            return true
        isSupportNewFeature = WatchFaceSharedUtil.getOSCapability(context)
        return isAvailableWatchfaceFeatureUsed(context)
    }

    @JvmStatic
    fun getWatchfaceFeatureValue(): Int {
        return isSupportNewFeature
    }

    @JvmStatic
    fun setWatchfaceFeatureValue(set: Int) {
        isSupportNewFeature = set
    }

    @JvmStatic
    fun getWatchfaceOOBEResourceFileUri(): Uri? {
        return oobe_fileUri
    }

    @JvmStatic
    fun setWatchfaceOOBEResourceFileUri(uri: Uri?) {
        oobe_fileUri = uri
    }

    @JvmStatic
    fun setWatchfaceEditWithUserStyle(set: Boolean) {
        isWatchfaceEditWithUserStyle = set
    }

    @JvmStatic
    fun isWatchfaceEditWithUserStyle() : Boolean {
        return isWatchfaceEditWithUserStyle
    }



//    @JvmStatic
//    fun isWatchfaceUpdateEnable(packageName: String): Boolean {
//        val result = mUpdateHashMap[packageName]
//        return result ?: false
//    }
}

public class WatchfacePackageClassSet  implements Parcelable {
    private String packageName;
    private String className;
    private int favoriteId;
    private int versionInfo;

    private String type;

    public WatchfacePackageClassSet(String packageName, String className) {
        this.packageName = packageName;
        this.className = className;
        this.favoriteId = WatchFaceConstant.UNKNOWN_FAVORITE_ID;
        this.versionInfo = 0;
    }

    public WatchfacePackageClassSet(String packageName, String className, String type) {
        this.packageName = packageName;
        this.className = className;
        this.favoriteId = WatchFaceConstant.UNKNOWN_FAVORITE_ID;
        this.versionInfo = 0;
        this.type = type;
    }

    public WatchfacePackageClassSet(String packageName, String className, int favoriteId) {
        this.packageName = packageName;
        this.className = className;
        this.favoriteId = favoriteId;
        this.versionInfo = 0;
    }

    protected WatchfacePackageClassSet(Parcel in) {
        this.packageName = in.readString();
        this.className = in.readString();
    }

    public String getPackageName() {
        return packageName;
    }

    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    public String getClassName() {
        return className;
    }

    public void setClassName(String className) {
        this.className = className;
    }

    public void setFavoriteId(int id) {
        this.favoriteId = id;
    }

    public int getFavoriteId() {
        return this.favoriteId;
    }

    public void setVersionInfo(int version) {
        this.versionInfo = version;
    }

    public int getVersionInfo() {
        return this.versionInfo;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getType() {
        return this.type;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(packageName);
        dest.writeString(className);
        dest.writeInt(favoriteId);
        dest.writeInt(versionInfo);
    }

    public final void readFromParcel(Parcel in) {
        this.packageName = in.readString();
        this.className = in.readString();
        this.favoriteId = in.readInt();
        this.versionInfo = in.readInt();
    }

    public static final Creator<WatchfacePackageClassSet> CREATOR = new Creator<WatchfacePackageClassSet>() {
        @Override
        public WatchfacePackageClassSet createFromParcel(Parcel in) {
            return new WatchfacePackageClassSet(in);
        }

        @Override
        public WatchfacePackageClassSet[] newArray(int size) {
            return new WatchfacePackageClassSet[size];
        }
    };

    public String toString() {
        return this.packageName + "/" + this.className;
    }

    public String toStringData() {
        return this.packageName + "/" + this.className + "[" + this.versionInfo + "]";
    }
}

public class WatchfaceOrderList implements Parcelable {
    private static final String TAG = "[WF]_" + WatchfaceOrderList.class.getSimpleName();
    @SerializedName("count")
    private Integer mCount = 0;
    @SerializedName("orderList")
    private byte[] orderBytes;
    @SerializedName("favoriteIdOrderList")
    private ArrayList<Integer> mFavoriteIdOrderList = new ArrayList<>();

    private transient ArrayList<WatchfacePackageClassSet> mOrderList = new ArrayList<>();
    private transient HashMap<Integer, Integer> mFavoriteIdHashMap = new HashMap<>();

    public WatchfaceOrderList() {
    }

    public WatchfaceOrderList(Parcel in) {
        mCount = in.readInt();
        mOrderList = in.createTypedArrayList(WatchfacePackageClassSet.CREATOR);
        mFavoriteIdOrderList =  (ArrayList<Integer>)in.readSerializable();
    }

    public static final Creator<WatchfaceOrderList> CREATOR = new Creator<WatchfaceOrderList>() {
        @Override
        public WatchfaceOrderList createFromParcel(Parcel in) {
            return new WatchfaceOrderList(in);
        }

        @Override
        public WatchfaceOrderList[] newArray(int size) {
            return new WatchfaceOrderList[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(mCount);
        dest.writeTypedList(mOrderList);
        dest.writeSerializable(mFavoriteIdOrderList);
    }

    public int getCount() {
        return mCount;
    }

    public void addOrderList(WatchfacePackageClassSet set) {
        mOrderList.add(set);
        mCount++;
    }

    public void addOrderList(WatchfacePackageClassSet set, int favoriteId) {
        mOrderList.add(set);
        mFavoriteIdOrderList.add(favoriteId);
        mCount++;
    }

    public void addFavoriteIdOrderList(int favoriteId) {
        mFavoriteIdOrderList.add(favoriteId);
        mCount++;
    }

    public ArrayList<WatchfacePackageClassSet> getOrderList() {
        return mOrderList;
    }

    public ArrayList<Integer> getFavoriteIdOrderList() {
        return mFavoriteIdOrderList;
    }

    public byte[] getOrderBytes() {
        return orderBytes;
    }

    public void setOrderBytes(byte[] bytes) {
        orderBytes = bytes;
    }

    public void clear() {
        mCount = 0;
        mOrderList.clear();
        mFavoriteIdOrderList.clear();
    }

    public String toStringLog(){
        StringBuilder result = new StringBuilder("WatchfaceOrderList");
        if(mCount != null)
            result.append('\n').append("Count : ").append(mCount);
        if(mOrderList != null) {
            result.append('\n').append("OrderList : ");
            for(WatchfacePackageClassSet setData : mOrderList) {
                result.append('\n').append("[").append(setData.getPackageName()+"]["+setData.getClassName() ).append("]");
            }
        }
        if(!mFavoriteIdOrderList.isEmpty()) {
            result.append('\n').append("favoriteIdOrderList : ");
            result.append('\n').append("[").append(mFavoriteIdOrderList.toString()).append("]");
        }
        return result.toString();
    }

    public void convertToByte() {
        if(mOrderList!= null && !mOrderList.isEmpty()) {
            Log.d(TAG, "convertToByte ");
            orderBytes = compress(mOrderList.toString());
            mOrderList.clear();
        }
    }

    public void convertToString() {
        if(orderBytes != null) {
            String data = decompress(orderBytes);
            if (data == null) {
                Log.w(TAG, "convertToString : data null");
                return;
            }
            data = data.replaceAll("[\\[\\]]","");
//            Log.d(TAG, "convertToString toString : " + data);
            mOrderList.clear();
            ArrayList<String> before = new ArrayList<String>(Arrays.asList(data.split(", ")));
            for(String set : before) {
//                Log.d(TAG, "convertToString before : " + set);
                ArrayList<String> after = new ArrayList<String>(Arrays.asList(set.split("/")));
                if(after.size() == 2) {
                    mOrderList.add(new WatchfacePackageClassSet(after.get(0), after.get(1)));
                }
            }
        } else {
            Log.d(TAG, "Error  orderBytes null !!!! ");
        }
    }

    public HashMap<Integer, Integer> getFavoriteIdHashMap() {
        mFavoriteIdHashMap.clear();
        if(!mFavoriteIdOrderList.isEmpty()) {
            int count = 1;
            for(int id : mFavoriteIdOrderList)
                mFavoriteIdHashMap.put(id, count++);
        }
        return mFavoriteIdHashMap;
    }

    public byte[] compress(String text) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            OutputStream out = new DeflaterOutputStream(baos);
            out.write(text.getBytes(StandardCharsets.UTF_8));
            out.close();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
        return baos.toByteArray();
    }

    public String decompress(byte[] bytes) {
        try (InflaterInputStream in = new InflaterInputStream(new ByteArrayInputStream(bytes));
             ByteArrayOutputStream baos = new ByteArrayOutputStream()){
            byte[] buffer = new byte[8192];
            int len;
            while ((len = in.read(buffer)) > 0) baos.write(buffer, 0, len);
            return new String(baos.toByteArray(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
            throw new AssertionError(e);
        }
    }
}
public class ExWatchFace implements Parcelable {
    private static final String TAG = ExWatchFace.class.getSimpleName();
    @SerializedName("ClassName")
    private String className;
    @SerializedName("DisplayName")
    private String displayName;
    @SerializedName("PackageName")
    private String packageName;
    @SerializedName("Type")
    private String type;
    @SerializedName("favoriteId")
    private int favoriteId;
    @SerializedName("version")
    private int version;
    @SerializedName("Selected")
    private boolean isSelected;
    @SerializedName("NewlyDownloaded")
    private boolean isNewlyDownloaded;
    @SerializedName("UpdateEnable")
    private boolean isUpdateEnable;
    @SerializedName("Editable")
    private boolean isEditable;
    @SerializedName("Preload")
    private boolean isPreload;
    @SerializedName("relatedApp")
    private boolean isRelatedAppExisted;
    @SerializedName("supportsMultipleFavoriteInstances")
    private boolean supportsMultipleFavoriteInstances;
    @SerializedName("flavors")
    private ArrayList<String> flavorList;
    @SerializedName("appVersion")
    private long appVersion;

    private String mCustomizableItems;

    public ExWatchFace(Parcel in) {
        className = in.readString();
        displayName = in.readString();
        packageName = in.readString();
        type = in.readString();
        favoriteId = in.readInt();
        version = in.readInt();
        isSelected = in.readByte() == 1;
        isNewlyDownloaded = in.readByte() == 1;
        isUpdateEnable = in.readByte() == 1;
        isEditable =in.readByte() == 1;
        isPreload =in.readByte() == 1;
        isRelatedAppExisted =in.readByte() == 1;
        supportsMultipleFavoriteInstances =in.readByte() == 1;
        this.mCustomizableItems = in.readString();
        flavorList = in.createStringArrayList();
        appVersion = in.readLong();
    }

    public static final Creator<ExWatchFace> CREATOR = new Creator<ExWatchFace>() {
        @Override
        public ExWatchFace createFromParcel(Parcel in) {
            return new ExWatchFace(in);
        }

        @Override
        public ExWatchFace[] newArray(int size) {
            return new ExWatchFace[size];
        }
    };

    public ExWatchFace() {
        className = "";
        displayName = "";
        packageName = "";
        type = WatchFaceConstant.TYPE_NOT_CHECKED;
        favoriteId = WatchFaceConstant.AVAILAVLE_FAVORITE_ID;
        version = 0;
        isSelected = false;
        isNewlyDownloaded = false;
        isUpdateEnable = false;
        isEditable = false;
        isPreload = false;
        isRelatedAppExisted = false;
        supportsMultipleFavoriteInstances = false;
        mCustomizableItems = "";
    }
    public String toString(){
        StringBuilder result = new StringBuilder();
        result.append("\n Class Name : " ).append(className);
        result.append(", Display Name : " ).append(displayName);
//        result.append("\n Package Name : " ).append(packageName);
//        result.append("\n path : " ).append(previewImageFileName);
        result.append(", type : " ).append(type);
        result.append(" favoriteId : " ).append(favoriteId);
//        result.append("\n version : " ).append(version);
        result.append(", isSelected : " ).append(isSelected);
        result.append(", isNewlyDownloaded : " ).append(isNewlyDownloaded);
//        result.append("\n isUpdateEnable : " ).append(isUpdateEnable);
        result.append(", isEditable : " ).append(isEditable);
        result.append(", isPreload : " ).append(isPreload);
        result.append(", isRelatedAppExisted : " ).append(isRelatedAppExisted);
        result.append(", supportsMultipleFavoriteInstances : " ).append(supportsMultipleFavoriteInstances);
        if(flavorList != null) {
            result.append(", flavorList : ").append(flavorList);
        }
        result.append(", appVersion : " ).append(appVersion);
        return result.toString();
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(className);
        dest.writeString(displayName);
        dest.writeString(packageName);
        dest.writeString(type);
        dest.writeInt(favoriteId);
        dest.writeInt(version);
        dest.writeByte((byte) (isSelected ? 1 : 0));
        dest.writeByte((byte) (isNewlyDownloaded ? 1 : 0));
        dest.writeByte((byte) (isUpdateEnable ? 1 : 0));
        dest.writeByte((byte) (isEditable ? 1 : 0));
        dest.writeByte((byte) (isPreload ? 1 : 0));
        dest.writeByte((byte) (isRelatedAppExisted ? 1 : 0));
        dest.writeByte((byte) (supportsMultipleFavoriteInstances ? 1 : 0));
        dest.writeString(mCustomizableItems);
        dest.writeStringList(flavorList);
        dest.writeLong(appVersion);
    }

    public void setClassName(String name){
        className = name;
    }
    public String getClassName(){
        return this.className;
    }
    public void setDisplayName(String name){
        displayName = name;
    }
    public String getDisplayName(){
        return this.displayName;
    }
    public void setPackageName(String name){
        this.packageName = name;
    }
    public String getPackageName(){
        return this.packageName;
    }
    public String getPreviewImageFileName(){
        String filePath = packageName + File.separator + className + File.separator;
        if(this.favoriteId > WatchFaceConstant.AVAILAVLE_FAVORITE_ID)
            filePath = filePath + WatchFaceSharedConstant.ID + this.favoriteId + File.separator;
        filePath = filePath + this.className + WatchFaceConstant.PNG_EXTENSION;
        return filePath;
    }

    public void setType(String type){
        this.type = type;
    }
    public String getType(){
        return this.type;
    }
    public void setFavoriteId(int id){
        this.favoriteId = id;
    }
    public int getFavoriteId(){
        return this.favoriteId;
    }
    public void setVersion(int version){
        this.version = version;
    }
    public int getVersion(){
        return this.version;
    }
    public void setSelected(boolean set){
        this.isSelected = set;
    }
    public boolean isSelected(){
        return this.isSelected;
    }
    public void setEditable(boolean set) {
        this.isEditable = set;
    }
    public boolean isEditable() {
        return this.isEditable;
    }
    public void setPreload(boolean set) {
        this.isPreload = set;
    }
    public boolean isPreload() {
        return this.isPreload;
    }
    public void setNewlyDownloaded(boolean set){
        this.isNewlyDownloaded = set;
    }
    public boolean isNewlyDownloaded(){
        return this.isNewlyDownloaded;
    }
    public void setUpdateEnable(boolean set){
        this.isUpdateEnable = set;
    }
    public boolean isUpdateEnable(){
        return this.isUpdateEnable;
    }
    public void setRelatedAppExisted(boolean set){
        this.isRelatedAppExisted = set;
    }
    public boolean isRelatedAppExisted(){
        return this.isRelatedAppExisted;
    }

    public void setSupportsMultipleFavoriteInstances(boolean set){
        this.supportsMultipleFavoriteInstances = set;
    }
    public boolean isSupportsMultipleFavoriteInstances(){
        return this.supportsMultipleFavoriteInstances;
    }

    public void setSubString(String subString) {
        mCustomizableItems = subString;
    }

    public String getSubString() {
        return mCustomizableItems;
    }

    public String[] getCustomizableItemList() {
        String subString = "";
        try {
            Gson gson = new Gson();
            CustomizableItemResourceData data = gson.fromJson(mCustomizableItems, CustomizableItemResourceData.class);
            subString =  data.getOldFormattedCustomizeData();
        } catch (Exception e) {
            subString = mCustomizableItems;
        }

        if (TextUtils.isEmpty(subString)) {
            return null;
        }
        return subString.split(";");
    }

    public void addFlavorList(ArrayList<String> ids) {
        flavorList = new ArrayList<>();
        flavorList.addAll(ids);
    }

    public ArrayList<String> getFlavorList() {
        return flavorList;
    }

    public void setAppVersion(long appVersion){
        this.appVersion = appVersion;
    }

    public long getAppVersion(){
        return this.appVersion;
    }
}
