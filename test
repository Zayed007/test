package com.samsung.android.companionservice.watchface.bnr

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.WorkerParameters
import androidx.work.workDataOf
import com.samsung.android.companionservice.watchface.util.WFLog
import com.samsung.android.plugin.sharedlib.utils.copyFile
import java.io.File

open class WfBnrWorkerBase(cont: Context, param: WorkerParameters) : CoroutineWorker(cont, param) {
    protected var mContext: Context? = null

    override suspend fun doWork(): Result {
        TODO("Not yet implemented")
    }

    open fun init(context: Context) {
        mContext = context
    }

    open fun updateBackupFile() {
        TODO("Not yet implemented")
    }

    open fun backupResource(file: File): Int {
        WFLog.d(TAG, " backupResource ${file.absolutePath}")
        return if (cleanup(file)) {
            if (copyFile()) {
                RESULT_SUCCESS
            } else {
                RESULT_CPY_FAILED
            }
        } else RESULT_CLEANUP_FAILED
    }

    open fun cleanUp(): Boolean {
        return true
    }

    open fun restoreResource(file: File): Int {
        WFLog.d(TAG, " restoreResource ${file.absolutePath}")
        return if (cleanup(file)) {
            if (copyFile()) {
                RESULT_SUCCESS
            } else {
                RESULT_CPY_FAILED
            }
        } else RESULT_CLEANUP_FAILED

    }

    open fun cleanup(target: File): Boolean {
        WFLog.d(TAG, "cleanup : ${target.absolutePath}")
        var res = true
        target?.let { targetFile ->
            if (targetFile.exists()) {
                targetFile.listFiles()?.let {
                    it.forEach {
                        if (!it.delete()) {
                            if (res) res = false
                        }
                        WFLog.w(TAG, "${it.name}  deleted $res")
                    }
                }
            } else {
                targetFile.mkdirs()
            }
        }
        return res
    }

    open fun copyFile(): Boolean {
        return true
    }

    open fun copyDir(source: File, target: File) {
        var makeDirectory = false
        if (source.isDirectory) {
            if (!target.exists()) {
                makeDirectory = target.mkdir()
            }
            WFLog.d(TAG, "Value of MKDIR ::$makeDirectory")
            val children = source.list()
            if (children != null) {
                for (i in children.indices) {
                    copyDir(
                        File(source, children[i]),
                        File(target, children[i])
                    )
                }
            }
        } else {
            copySpecificFile(source, target)
        }
    }

    open fun copySpecificFile(source: File, target: File) {
        return copyFile(source, target)
    }

    open fun setOutPutData(pn: String, fi: Int, reason: Int, isBackup: Boolean): Data {
        return workDataOf(
            WF_RESOURCE_PACKAGE_NAME to pn,
            WF_RESOURCE_FAVORITE_ID to fi,
            REASON to reason,
            BACKUP_STATUS to isBackup
        )
    }

    protected companion object {
        const val TAG = "WfBnrWorkerBase"
        const val WF_RESOURCE_PACKAGE_NAME = "packageName"
        const val WF_RESOURCE_CLASS_NAME = "className"
        const val WF_RESOURCE_FAVORITE_ID = "favoriteId"
        const val ID = "id_"
        const val GM_FOLDER_PATH = "gmfolderPath"
        const val BACKUP_FOLDER = "backup"
        const val GALLERY_FOLDER = "Gallery"
        const val EMOJI_DATA_FOLDER = "galleryFolder"
        const val CUSTOM_PREVIEW = "customize_preview"
        const val RESULT_EXTENSION = "result.xml"
        const val MYPHOTO_FOLDER = "MyPhoto"
        const val MYPEBBLE_FOLDER = "MyPebble"
        const val PHOTOSTICKER_FOLDER = "PhotoSticker"
        const val AREMOJI_BACKUP_FOLDER = "com.samsung.android.watch.watchface.aremoji"
        const val MYPHOTO_BACKUP_FOLDER = "com.samsung.android.watch.watchface.myphoto"
        const val MYPEBBLE_BACKUP_FOLDER = "com.samsung.android.watch.watchface.mypebble"
        const val PHOTOSTICKER_BACKUP_FOLDER = "com.samsung.android.watch.watchface.photosticker"
        const val REASON = "reason"
        const val RESULT_BACKUP_ALREADY_EXIST = 3
        const val RESULT_SRC_NOT_EXIST = 2
        const val RESULT_SUCCESS = 1
        const val RESULT_UNKNOWN_EXCEPTION = 0
        const val RESULT_CPY_FAILED = -3
        const val RESULT_ZIP_FAILED = -4
        const val RESULT_AVATAR_NOT_EXIST = -5
        const val RESULT_CLEANUP_FAILED = -6
        const val RESULT_UNZIP_FAILED = -7
        const val RESULT_IS_DWF = -8
        const val BACKUP_STATUS = "backup_status"
        const val BACKUP_PREFIX = "backup_"

    }
}

class WfBnrAremojiWork(cont: Context, param: WorkerParameters) : WfBnrWorkerBase(cont, param) {

    internal var srcPath: String? = ""
    internal var targetPath: String? = ""
    internal var comparePath: String? = ""
    internal var src: File? = null
    internal var target: File? = null
    internal var compare: File? = null
    internal var output: Data? = null
    var isBackup = false

    @SuppressLint("RestrictedApi")
    override suspend fun doWork(): Result {
        return withContext(Dispatchers.IO) {
            val packageName = inputData.getString(WF_RESOURCE_PACKAGE_NAME)
            val className = inputData.getString(WF_RESOURCE_CLASS_NAME)
            var favoriteId = inputData.getInt(WF_RESOURCE_FAVORITE_ID, -1)
            isBackup = inputData.getBoolean(BACKUP_STATUS, false)

            try {
                WFLog.d(TAG, " WfBnrAremojiWork dowork")
                @Suppress("VARIABLE_WITH_REDUNDANT_INITIALIZER") var result = 1
                var path = inputData.getString(GM_FOLDER_PATH)
                var resourceFolder = "$packageName${File.separator}$className"
                var backupFolder =
                    "$BACKUP_FOLDER${File.separator}$AREMOJI_BACKUP_FOLDER${File.separator}$favoriteId"

                srcPath = path!!.plus(if (isBackup) resourceFolder else backupFolder)
                targetPath = path.plus(if (isBackup) backupFolder else resourceFolder)
                comparePath =
                    path!!.plus("$packageName${File.separator}$className${File.separator}$ID$favoriteId${File.separator}$EMOJI_DATA_FOLDER")

                WFLog.d(TAG, " srcPath $srcPath")
                WFLog.d(TAG, " comparePath $comparePath")
                WFLog.d(TAG, " targetPath $targetPath")

                src = File(srcPath)
                target = File(targetPath)
                compare = File(comparePath)
                if (!compare!!.exists()) {
                    result = RESULT_SRC_NOT_EXIST
                } else {
                    result = if (isBackup) backupResource(target!!) else restoreResource()
                }
                output = setOutPutData(packageName!!, favoriteId, result, isBackup)
                if (result <= 0) {
                    Result.Failure(output!!)
                } else {
                    Result.Success()
                }
            } catch (e: Exception) {
                WFLog.w(TAG, "WfAremojiWorker Exception : $e")
                output =
                    setOutPutData(packageName!!, favoriteId, RESULT_UNKNOWN_EXCEPTION, isBackup)
                Result.Failure()
            }!!
        }
    }

    private fun restoreResource(): Int {
        return if (copyFile()) {
            RESULT_SUCCESS
        } else {
            RESULT_CPY_FAILED
        }
    }

    override fun cleanup(target: File): Boolean {
        return super.cleanup(target)
    }

    override fun copyFile(): Boolean {
        WFLog.d(TAG, "copyFile Aremoji")
        compare!!.listFiles()?.let { compList ->
            if (!compList.isNullOrEmpty()) {
                compList.filter { it.name.startsWith("avatarsticker") }
                    .forEach { compFile ->
                        src!!.listFiles()?.let { fileList ->
                            fileList.filter {
                                it.nameWithoutExtension.equals(compFile.nameWithoutExtension) &&
                                        it.name.endsWith(".zip")
                            }.forEach {
                                WFLog.d(TAG, "copyFile1 srcPath $it")
                                var targetFile =
                                    File(targetPath!!.plus("${File.separator}${it.name}"))
                                WFLog.d(TAG, "copyFile1 targetpath $targetFile")
                                copySpecificFile(it, targetFile)
                            }
                        }
                    }
            }
        }
        return true
    }


    companion object {
        val TAG = "WfBnrAremojiWork"
    }
}
