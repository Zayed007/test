package com.samsung.android.companionservice.watchface.bnr

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.text.TextUtils
import com.google.android.libraries.wear.companion.watch.ConnectionState
import com.samsung.android.app.watchmanager.plugin.libfactory.util.FileEncryptionUtils
import com.samsung.android.companionservice.connection.sdkwrapper.ConnectionWrapper
import com.samsung.android.companionservice.constant.WatchFaceConstant.FAVORITE_LIST_BNR
import com.samsung.android.companionservice.linker.ConnectionCompanionLinker
import com.samsung.android.companionservice.service.WRCompanionServiceInterface
import com.samsung.android.companionservice.watchface.util.WFLog
import com.samsung.android.companionservice.watchface.util.WatchFaceUtil
import com.samsung.android.plugin.sharedlib.utils.SharedFileUtils
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedConstant
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil.getDeviceID
import com.samsung.android.plugin.sharedlib.watchface.WatchFaceSharedUtil.getWatchfaceFolderPath
import com.samsung.android.smartswitchfileshare.FileShareHelper
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.io.File

class WfSmartSwitchBnrReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val message = intent.action
        WFLog.d(TAG, "OnReceive - $message")
        when (message) {
            WfBnrConstants.WATCHFACE_BACKUP_REQ,
            WfBnrConstants.WATCHFACE_RESTORE_REQ -> {
                var instance = WatchfaceBnRManager.getInstance(context)
                instance.setContext(context)
                instance.onStartCommand(intent, 0, 0)
            }
            WfBnrConstants.WATCHFACE_LIST_BACKUP_REQ -> {
                backUpWatchfaceList(context, intent)
            }
            WfBnrConstants.WATCHFACE_LIST_RESTORE_REQ -> {
                restoreWatchfaceList(context, intent)
            }
            else -> {}
        }
    }

    fun backUpResponse(cont: Context, intent: Intent, deviceId: String?) {
        backup(
            cont,
            intent,
            WfBnrConstants.WATCHFACE_BACKUP_RES,
            getResourceBackupFolderPath(cont, deviceId),
            deviceId
        )
    }

    fun getResourceBackupFolderPath(context: Context?, deviceId: String?): File? {
        val filesDirectory =
            context?.let { FileEncryptionUtils.getEncryptionContext(it)?.filesDir }
        return File(StringBuilder().apply {
            append(
                filesDirectory
            ).append(File.separator)
            append(deviceId).append(File.separator)
            append(WatchFaceSharedConstant.WATCHFACE_RESOURCE_FOLDER_NAME).append(File.separator)
            append(WatchFaceSharedConstant.WF_BACKUP_FOLDER_NAME)
        }.toString())
    }

    private fun backUpWatchfaceList(context: Context, intent: Intent) {
        CoroutineScope(Dispatchers.IO).launch {
            val nodeId = intent.getStringExtra(WfBnrConstants.EXTRA_WATCH_DEVICE_ID)
            val deviceId = nodeId?.let { ConnectionCompanionLinker.getBTAddressFromNodeId(it) }
            WFLog.d(TAG, "backUpWatchfaceList : nodeID $nodeId , deviceId $deviceId")
            backup(
                context,
                intent,
                WfBnrConstants.WATCHFACE_LIST_BACKUP_RES,
                getWatchfaceListBnrPath(context, deviceId),
                deviceId
            )
        }
    }

    private fun restoreWatchfaceList(context: Context, intent: Intent) {
        if (getWatchConnectionState(context) == ConnectionState.DISCONNECTED) {
            WFLog.d(TAG, "restoreWatchfaceList - watch disconnected")
            sendResultResponse(
                context,
                WfBnrConstants.WATCHFACE_LIST_RESTORE_RES,
                WfBnrConstants.RESULT_FAIL,
                intent.getStringExtra(WfBnrConstants.EXTRA_SOURCE),
                intent.getStringExtra(WfBnrConstants.EXTRA_EXPORT_SESSION_TIME)
            )
            return
        }

        CoroutineScope(Dispatchers.IO).launch {
            var deviceId = getDeviceID(context)
            val dstFile = getWatchfaceListBnrPath(context, deviceId)
            if (dstFile != null && dstFile.exists()) {
                SharedFileUtils.deleteFile(dstFile.path)
            }

            if (restore(
                    context,
                    intent,
                    WfBnrConstants.WATCHFACE_LIST_RESTORE_RES,
                    File(getWatchfaceFolderPath(context))
                ) == WfBnrConstants.RESULT_SUCCESS
            ) {
                WFLog.w(TAG, "restoreWatchfaceList - send restore data")
                WRCompanionServiceInterface.restoreFavoriteInfo(deviceId)
            } else {
                WFLog.w(TAG, "restoreWatchfaceList - restore data failed")
            }
            writeLog(context, deviceId, false)
        }
    }


    fun watchfaceResourceRestore(): File? {
        //TODO_ PROCESS for  WatchfaceREsource Backup
        return null  // backup Folder Path
    }

    private fun getWatchfaceListBnrPath(context: Context?, deviceId: String?): File? {
        if (deviceId.isNullOrEmpty()) {
            return null
        }

        val filesDirectory =
            context?.let { FileEncryptionUtils.getEncryptionContext(it)?.filesDir }
        return File(StringBuilder().apply {
            append(
                filesDirectory
            ).append(File.separator)
            append(deviceId).append(File.separator)
            append(WatchFaceSharedConstant.WATCHFACE_RESOURCE_FOLDER_NAME).append(File.separator)
            append(FAVORITE_LIST_BNR)
        }.toString())
    }

    private fun getWatchConnectionState(context: Context): ConnectionState {
        val lastConnectedDeviceId = getDeviceID(context)
        WFLog.d(TAG, "getWatchConnectionState $lastConnectedDeviceId")

        if (TextUtils.isEmpty(lastConnectedDeviceId)) {
            return ConnectionState.DISCONNECTED
        }

        val connectionState = ConnectionWrapper.getConnectionState(lastConnectedDeviceId)
        if (connectionState != null) {
            WFLog.d(TAG, "getWatchConnectionState", "ConnectionState: $connectionState")
            if (connectionState == ConnectionState.BLUETOOTH)
                return connectionState
        } else {
            WFLog.e(TAG, "getWatchConnectionState : connectionState is Null.")
        }

        return ConnectionState.DISCONNECTED
    }

    private fun backup(
        context: Context,
        intent: Intent,
        response: String,
        sourceFile: File?,
        deviceId: String?
    ) {
        val source = intent.getStringExtra(WfBnrConstants.EXTRA_SOURCE)
        val sessionTime = intent.getStringExtra(WfBnrConstants.EXTRA_EXPORT_SESSION_TIME)
        val extraAction =
            intent.getIntExtra(WfBnrConstants.EXTRA_ACTION, WfBnrConstants.ACTION_BACKUP_RESTORE)
        var result = WfBnrConstants.RESULT_FAIL

        if (extraAction == WfBnrConstants.ACTION_BACKUP_CANCEL) {
            WFLog.e(TAG, "backup - action value cancel")
            return
        }
        sourceFile?.let { file ->
            if (file.exists()) {
                try {
                    val fileShareHelper = FileShareHelper(context, TAG)
                    fileShareHelper.copy(file, intent)
                    result = WfBnrConstants.RESULT_SUCCESS
                    writeLog(context, deviceId, true)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            } else {
                WFLog.w(TAG, "backup - file doesn't exist")
            }
        }
        sendResultResponse(context, response, result, source, sessionTime)
    }

    private fun restore(
        context: Context,
        intent: Intent,
        response: String,
        dstFile: File?
    ): Int {
        val source = intent.getStringExtra(WfBnrConstants.EXTRA_SOURCE)
        val sessionTime = intent.getStringExtra(WfBnrConstants.EXTRA_EXPORT_SESSION_TIME)
        var result = WfBnrConstants.RESULT_FAIL
        dstFile?.let {
            try {
                val fileShareHelper = FileShareHelper(context, TAG)
                fileShareHelper.copy(intent, it)
                result = WfBnrConstants.RESULT_SUCCESS
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
        sendResultResponse(context, response, result, source, sessionTime)
        return result
    }

    private fun sendResultResponse(
        context: Context,
        msg: String,
        errorCode: Int,
        source: String?,
        sessionTime: String?
    ) {
        val intent = Intent(msg)
        WFLog.d(TAG, "sendResultResponse $msg $source")
        intent.putExtra(
            WfBnrConstants.RESULT,
            if (errorCode == WfBnrConstants.RESULT_SUCCESS) WfBnrConstants.RESULT_SUCCESS else WfBnrConstants.RESULT_FAIL
        )
        intent.putExtra(WfBnrConstants.EXTRA_ERR_CODE, errorCode)
        intent.putExtra(WfBnrConstants.EXTRA_REQ_SIZE, 0)
        intent.putExtra(WfBnrConstants.EXTRA_SOURCE, source)
        intent.putExtra(WfBnrConstants.EXTRA_EXPORT_SESSION_TIME, sessionTime)
        context.sendBroadcast(intent, WfBnrConstants.SS_WEAR_PROVIDER_PERMISSION)
    }

    private fun writeLog(context: Context, deviceId: String?, isBackUp : Boolean){
        val status = if(isBackUp)"BackUp" else "Restore"
        WatchFaceUtil.convertDataSyncList(context, deviceId)?.let{ wfListHash ->
            if(wfListHash.isNotEmpty()){
                WFLog.w(TAG, "wf$status:List: favoriteList File Exist")
                for (key in wfListHash.keys) {
                    WFLog.w(TAG, "wf$status: className : $key")
                    wfListHash[key]?.let { values ->
                        WFLog.w(TAG, "wf$status: favoriteIds : $values")
                    }
                }
            } else {
                WFLog.w(TAG, "wf$status: no List in favoriteList file")
            }
        }
    }

    companion object {
        const val TAG = "WfSmartSwitchBnrReceiver"
    }
}

